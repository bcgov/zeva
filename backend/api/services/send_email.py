from datetime import datetime
import logging
import json

from django.conf import settings

from requests.auth import HTTPBasicAuth
from email.header import Header
from email.utils import formataddr
from api.models.user_profile import UserProfile
from api.models.notification import Notification
from api.models.credit_transfer_statuses import CreditTransferStatuses
from api.models.sales_submission_statuses import SalesSubmissionStatuses
from api.models.model_year_report_statuses import ModelYearReportStatuses
from api.models.vehicle_statuses import VehicleDefinitionStatuses
from api.models.credit_agreement_statuses import CreditAgreementStatuses
from api.models.notification_subscription import NotificationSubscription
from api.models.organization import Organization
from api.models.credit_transfer import CreditTransfer
from api.models.sales_submission import SalesSubmission
from api.models.vehicle import Vehicle
from api.models.model_year_report import ModelYearReport
from api.models.credit_agreement import CreditAgreement

import requests
from django.db.models import Q
from typing import List

LOGGER = logging.getLogger(__name__)


def get_email_service_token() -> dict:
    """
    Retrieves an authentication token from the Common Hosted Email Service (CHES) API.

    This method sends a request to the CHES authentication URL to obtain an access token
    using the client_id and client_secret from the settings. The token is required to send
    emails through the CHES API.

    :return: A dictionary containing the token information if successful, or None if an error occurs.
    """
    if settings.DEBUG:
        print('starting email service')

    client_id = settings.EMAIL['EMAIL_SERVICE_CLIENT_ID']
    client_secret = settings.EMAIL['EMAIL_SERVICE_CLIENT_SECRET']
    url = settings.EMAIL['CHES_AUTH_URL']
    if not client_id:
        LOGGER.error("Email service client id is not configured")
        return {"error": "Email service client id is not configured"}
    if not client_secret:
        LOGGER.error("Email service client secret is not configured")
        return {"error": "Email service client secret is not configured"}
    if not url:
        LOGGER.error("Common hosted email service authentication url is not configured")
        return {"error": "Common hosted email service authentication url is not configured"}
    payload = {"grant_type": "client_credentials"}
    header = {"content-type": "application/x-www-form-urlencoded"}
    try:
        if settings.DEBUG:
            print('fetching email token')

        token_rs = requests.post(
            url, 
            data=payload,
            auth=HTTPBasicAuth(client_id, client_secret),
            headers=header, 
            verify=True
        )
        if not token_rs.status_code == 200:
            if settings.DEBUG:
                print("Error: Unexpected response", token_rs.text.encode('utf8'))
            LOGGER.error("Error: Unexpected response", token_rs.text.encode('utf8'))
            return {"error": "Unexpected response"}
        json_obj = token_rs.json()
        return json_obj
    except requests.exceptions.RequestException as e:
        if settings.DEBUG:
            print("Error: {}".format(e))
        LOGGER.error("Error: {}".format(e))
        return {"error": str(e)}


def generate_email_body(email_type: str, link: str, test_info: dict) -> str:
    """
    Generates an email body based on the provided email_type and test_info parameters.

    Constructs an email body with the given email_type and test_info. The email content may
    differ depending on the environment (prod or non-prod). In non-prod environments, the
    email will include additional action information.

    :param email_type: A string describing the type of email being sent, e.g. "credit transfer update".
    :param test_info: A dictionary containing test information, such as user, actions, action descriptions, and time.
    :return: A string representing the email body in HTML format.
    """

    body = f"""\
    <html>
    <body>
    This email was generated by the Government of B.C. Zero-Emission Vehicle Reporting System.
    <p>A {email_type} has occurred within the Zero-Emission Vehicle Reporting System. For more details, please go to: <a href={link}>{link}</a></p>
    <p>You received this email because you subscribed at the site above, to stop receiving these email logon to your account here <a href="https://zeroemissionvehicles.gov.bc.ca/notifications">https://zeroemissionvehicles.gov.bc.ca/notifications</a></p>
    """

    if settings.ENV_NAME != "prod":
        action_info = "".join(
            f"""<p>Action: {action}</p>
            <p>Description: {description}</p>"""
            for action, description in zip(test_info["actions"], test_info["action_descriptions"])
        )

        body += f"""\
        <p>User: {test_info['user']}</p>
        {action_info}
        <p>Time: {test_info['time']}</p>
        </body>
        </html>
        """
    else:
        body += """\
        </body>
        </html>
        """
    if settings.DEBUG:
        print('generated email body', body)

    return body


def send_email(recipient_emails: List[str], email_type: str, direct_link: str, test_info: dict):
    """
    Sends an email to the specified recipients with the given email type and test information.

    This method constructs an email body based on the provided email_type and test_info parameters, then
    sends the email using the Common Hosted Email Service (CHES) API. The email will be sent to the
    specified recipient_emails, with the subject set as "BC ZEVA Notification". The email's content may
    differ depending on the environment and the email_type.

    :param recipient_emails: A list of recipient email addresses as strings.
    :param email_type: A string describing the type of email being sent, e.g. "<b>credit transfer update</b>".
    :param test_info: A dictionary containing test information, such as user, actions, action descriptions, and time.
    :return: None if the email is sent successfully, or a dictionary containing an error message if an error occurs.
    """

    if settings.DEBUG:
        print('drafting email')
    
    sender_email = settings.EMAIL['SENDER_EMAIL']
    sender_name = settings.EMAIL['SENDER_NAME']
    url = settings.EMAIL['CHES_EMAIL_URL']

    if not sender_email:
        LOGGER.error("Sender email address not configured")
        return
    if not url:
        LOGGER.error("CHES email url not configured")
        return
    if not sender_name:
        LOGGER.error("Sender name not configured")
        return
    if not recipient_emails:
        LOGGER.error("No recipient email address provided")
        return
    if not email_type:
        LOGGER.error("No email type provided")
        return
    
    body = generate_email_body(email_type, direct_link, test_info)

    subject = "BC ZEVA Notification"
    bodyType = "html"
    attachment = ""

    token = get_email_service_token()
    if not token or 'access_token' not in token:
        if settings.DEBUG:
            print('access_token failed')
        LOGGER.error("No email service token provided", token)
        return
    auth_token = token['access_token']

    sender_info = formataddr((str(Header(sender_name, "utf-8")), sender_email))

    data = {
            "bcc": recipient_emails,
            "bodyType": bodyType,
            "body": body,
            "cc": [],
            "delayTS": 0,
            "encoding": "utf-8",
            "from": sender_info,
            "priority": "normal",
            "subject": subject,
            "to": ["ZEVRegulationDoNotReply@gov.bc.ca"],
            "tag": "email_1",
            "attachments": attachment
           }

    headers = {"Authorization": 'Bearer ' + auth_token,
               "Content-Type": "application/json"}
    try:
        if settings.DEBUG:
            print('posting email request')

        response = requests.post(
            url,
            data=json.dumps(data),
            headers=headers
        )
        if not response.status_code == 201:
            if settings.DEBUG:
                print("Error: Email failed! %s", response.text.encode('utf8'))
            LOGGER.error("Error: Email failed! %s", response.text.encode('utf8'))
            return

        email_res = response.json()
        if email_res:
            if settings.DEBUG:
                print("Email sent successfully!", email_res['messages'][0]['msgId'])
            LOGGER.debug("Email sent successfully!", email_res['messages'][0]['msgId'])
            return
    except requests.exceptions.RequestException as e:
        LOGGER.error("Error: {}".format(e))
        return


def get_subscribed_user_emails(notifications, obj, request_type):
    """
    Retrieves the subscribed user emails for the given notifications, object, and request type.

    This method filters the user profiles that are subscribed to specific notifications,
    belong to certain organizations, and have valid email addresses. The obj parameter
    can be different types of objects (e.g., CreditTransfer, ModelYearReport) depending
    on the method that is calling this function.

    :param notifications: A list of notification IDs to filter the subscriptions.
    :param obj: An object that can be of different types depending on the calling method.
    :param request_type: A string that indicates the type of request ('credit_transfer', 'model_year_report', etc.).
    :return: A list of subscribed user emails.
    """
    if settings.DEBUG:
        print('starting get_subscribed_user_emails')

    govt_org = Organization.objects.filter(is_government=True).first()
    subscribed_users = NotificationSubscription.objects.values_list('user_profile_id', flat=True).filter(
        notification__id__in=notifications).filter(user_profile__is_active=True)

    if settings.DEBUG:
        print('subscribed users', subscribed_users)

    if request_type == 'credit_transfer':
        user_emails = UserProfile.objects.values_list('email', flat=True).filter(
            Q(organization_id__in=[obj.debit_from_id, obj.credit_to_id, govt_org.id]) &
            Q(id__in=subscribed_users)).exclude(email__isnull=True).exclude(email__exact='').exclude(username=obj.update_user)
    elif request_type == 'model_year_report':
        user_emails = UserProfile.objects.values_list('email', flat=True).filter(
            Q(organization_id__in=[obj.organization.id, govt_org.id]) &
            Q(id__in=subscribed_users)).exclude(email__isnull=True).exclude(email__exact='').exclude(username=obj.update_user)
    else:
        user_emails = UserProfile.objects.values_list('email', flat=True).filter(
            Q(organization_id__in=[obj.organization, govt_org.id]) &
            Q(id__in=subscribed_users)).exclude(email__isnull=True).exclude(email__exact='').exclude(username=obj.update_user)

    if settings.DEBUG:
        print('get_subscribed_user_emails', user_emails)

    return user_emails


def get_notification_objects(notifications):
    """
    Retrieves the Notification objects for the given list of notification IDs.

    :param notifications: A list of notification IDs.
    :return: A QuerySet of Notification objects.
    """
    return Notification.objects.filter(id__in=notifications)


def prepare_test_info(request, notification_objects):
    """
    Prepares a dictionary containing test information based on the given request and notification objects.

    This method extracts user, action names, action descriptions, and the current time from the provided
    parameters and stores them in a dictionary.

    :param request: A request object containing user information.
    :param notification_objects: A QuerySet of Notification objects.
    :return: A dictionary containing test information.
    """
    if settings.DEBUG:
        print('preparing test info')

    test_info = {}
    try:
        test_info['user'] = request.update_user
    except AttributeError as error:
        test_info['user'] = request.user.update_user

    test_info['actions'] = []
    test_info['action_descriptions'] = []
    for object in notification_objects:
        test_info['actions'].append(object.name)
        test_info['action_descriptions'].append(object.description)
    test_info['time'] = datetime.now().strftime("%d/%m/%Y %H:%M:%S")

    if settings.DEBUG:
        print('test info', test_info)

    return test_info


def notifications_credit_transfers(transfer: object, transfer_sent_back_to_analyst: bool, transfer_saved_by_analyst: bool):
    """
    Handles notifications for credit transfer events based on the transfer status.

    :param transfer: The credit transfer object with its current status.
    :param transfer_sent_back_to_analyst: whether the transfer was sent back to the analyst
    :param transfer_saved_by_analyst: whether the transfer was saved by the analyst
    """
    validation_status = transfer.status
    notifications = None
    if validation_status == CreditTransferStatuses.VALIDATED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='CREDIT_TRANSFER_RECORDED_GOVT') |
            Q(notification_code='CREDIT_TRANSFER_RECORDED'))

    elif validation_status == CreditTransferStatuses.SUBMITTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_TRANSFER_SUBMITTED')

    elif validation_status == CreditTransferStatuses.RECOMMEND_APPROVAL:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_TRANSFER_RECOMMEND_APPROVAL')

    elif validation_status == CreditTransferStatuses.RECOMMEND_REJECTION:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_TRANSFER_RECOMMEND_REJECT')

    elif validation_status == CreditTransferStatuses.APPROVED:
        if transfer_sent_back_to_analyst:
            notifications = Notification.objects.values_list('id', flat=True).filter(
                Q(notification_code='CREDIT_TRANSFER_APPROVED'))
        elif not transfer_saved_by_analyst:
            notifications = Notification.objects.values_list('id', flat=True).filter(
                Q(notification_code='CREDIT_TRANSFER_APPROVED') |
                Q(notification_code='CREDIT_TRANSFER_APPROVED_PARTNER'))

    elif validation_status == CreditTransferStatuses.DISAPPROVED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_TRANSFER_REJECTED_PARTNER')

    elif validation_status == CreditTransferStatuses.RESCINDED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='CREDIT_TRANSFER_RESCINDED') |
            Q(notification_code='CREDIT_TRANSFER_RESCINDED_PARTNER'))

    elif validation_status == CreditTransferStatuses.RESCIND_PRE_APPROVAL:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_TRANSFER_RESCINDED_PARTNER')

    elif validation_status == CreditTransferStatuses.REJECTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='CREDIT_TRANSFER_REJECTED_GOVT') |
            Q(notification_code='CREDIT_TRANSFER_REJECTED'))

    if settings.DEBUG:
        print('notifications_credit_transfers', notifications)

    if notifications:
        send_credit_transfer_emails(notifications, transfer)


def notifications_model_year_report(updated_model_year_report, report_returned_to_supplier):
    """
    Handles notifications for model year report events based on the validation status.

    :param updated_model_year_report: The new/updated model year report.
    :param report_returned_to_supplier: Whether the report was returned to the supplier.
    """
    validation_status = updated_model_year_report.validation_status
    notifications = None
    if validation_status == ModelYearReportStatuses.ASSESSED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='MODEL_YEAR_REPORT_ASSESSED_SUPPLIER') |
            Q(notification_code='MODEL_YEAR_REPORT_ASSESSED_GOVT'))
    elif validation_status == ModelYearReportStatuses.SUBMITTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='MODEL_YEAR_REPORT_SUBMITTED') 
    elif validation_status == ModelYearReportStatuses.RECOMMENDED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='MODEL_YEAR_REPORT_RECOMMENDED') 
    elif validation_status == ModelYearReportStatuses.RETURNED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='MODEL_YEAR_REPORT_RETURNED')
    elif report_returned_to_supplier:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='MODEL_YEAR_REPORT_RETURNED_TO_SUPPLIER')

    if settings.DEBUG:
        print('notifications_model_year_report', notifications)

    if notifications:
        send_model_year_report_emails(notifications, updated_model_year_report)


def notifications_credit_agreement(agreement: object):
    """
    Handles notifications for credit agreement events based on the agreement status.

    :param agreement: The credit agreement object with its current status.
    """
    validation_status = agreement.status
    notifications = None
    if validation_status == CreditAgreementStatuses.ISSUED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='CREDIT_AGREEMENT_ISSUED_SUPPLIER') |
            Q(notification_code='CREDIT_AGREEMENT_ISSUED_GOVT'))
    elif validation_status == CreditAgreementStatuses.RECOMMENDED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_AGREEMENT_RECOMMENDED') 
    elif validation_status == CreditAgreementStatuses.RETURNED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_AGREEMENT_RETURNED_WITH_COMMENT') 

    if settings.DEBUG:
        print('notifications_credit_agreement', notifications)

    if notifications:
        send_credit_agreement_emails(notifications, agreement)


def notifications_credit_application(submission: object):
    """
    Handles notifications for credit application events based on the submission status.

    :param submission: The credit application submission object with its current status.
    """
    validation_status = submission.validation_status
    notifications = None
    if validation_status == SalesSubmissionStatuses.VALIDATED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='CREDIT_APPLICATION_ISSUED') |
            Q(notification_code='CREDIT_APPLICATION_ISSUED_GOVT'))

    elif validation_status == SalesSubmissionStatuses.CHECKED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_APPLICATION_CHECKED')

    elif validation_status == SalesSubmissionStatuses.RECOMMEND_APPROVAL:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_APPLICATION_RECOMMEND_APPROVAL')

    elif validation_status == SalesSubmissionStatuses.SUBMITTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='CREDIT_APPLICATION_SUBMITTED')

    if settings.DEBUG:
        print('notifications_credit_application', notifications)

    if notifications:
        send_credit_application_emails(notifications, submission)


def notifications_zev_model(vehicle: object, validation_status: str):
    """
    Handles notifications for ZEV model events based on the validation status.

    :param vehicle: The vehicle object containing relevant data.
    :param validation_status: The validation status of the ZEV model.
    """
    notifications = None
    if validation_status == VehicleDefinitionStatuses.VALIDATED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='ZEV_MODEL_VALIDATED')

    elif validation_status == VehicleDefinitionStatuses.REJECTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='ZEV_MODEL_REJECTED')

    elif validation_status == VehicleDefinitionStatuses.SUBMITTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            Q(notification_code='ZEV_MODEL_SUBMITTED') |
            Q(notification_code='ZEV_MODEL_RANGE_REPORT_SUBMITTED'))

    elif validation_status == VehicleDefinitionStatuses.CHANGES_REQUESTED:
        notifications = Notification.objects.values_list('id', flat=True).filter(
            notification_code='ZEV_MODEL_RANGE_REPORT_TEST_RESULT_REQUESTED')

    if settings.DEBUG:
        print('notifications_zev_model', notifications)

    if notifications:
        send_zev_model_emails(notifications, vehicle)


def get_direct_link(object):
    result = settings.FRONTEND_URL_BASE
    object_id = str(object.id)
    if isinstance(object, CreditTransfer):
        result = result + '/credit-transfers/' + object_id
    elif isinstance(object, SalesSubmission):
        result = result + '/credit-requests/' + object_id
    elif isinstance(object, Vehicle):
        result = result + '/vehicles/' + object_id
    elif isinstance(object, ModelYearReport):
        result = result + '/compliance/reports/' + object_id + '/supplier-information'
    elif isinstance(object, CreditAgreement):
        result = result + '/credit-agreements/' + object_id
    return result


def send_credit_transfer_emails(notifications, transfer):
    """
    Sends emails to subscribed users with credit transfer updates.

    :param notifications: Notification objects for the credit transfer event.
    :param transfer: The credit transfer object.
    """
    if settings.DEBUG:
        print('send_credit_transfer_emails')

    request_type = 'credit_transfer'
    user_emails = get_subscribed_user_emails(notifications, transfer, request_type)
    notification_objects = get_notification_objects(notifications)
    test_info = prepare_test_info(transfer, notification_objects)
    direct_link = get_direct_link(transfer)

    if user_emails:
        email_type = '<b>credit transfer update</b>'
        send_email(list(user_emails), email_type, direct_link, test_info)


def send_credit_application_emails(notifications, submission):
    """
    Sends emails to subscribed users with credit application updates.

    :param notifications: Notification objects for the credit application event.
    :param submission: The credit application submission object.
    """
    if settings.DEBUG:
        print('send_credit_application_emails')
    
    request_type = 'credit_application'
    user_emails = get_subscribed_user_emails(notifications, submission, request_type)
    notification_objects = get_notification_objects(notifications)
    test_info = prepare_test_info(submission, notification_objects)
    direct_link = get_direct_link(submission)

    if user_emails:
        email_type = '<b>credit application update</b>'
        send_email(list(user_emails), email_type, direct_link, test_info)


def send_zev_model_emails(notifications, vehicle):
    """
    Sends emails to subscribed users with ZEV model updates.

    :param notifications: Notification objects for the ZEV model event.
    :param request: The request object containing relevant data.
    """
    if settings.DEBUG:
        print('send_zev_model_emails')
    
    request_type = 'zev_model'
    user_emails = get_subscribed_user_emails(notifications, vehicle, request_type)
    notification_objects = get_notification_objects(notifications)
    test_info = prepare_test_info(vehicle, notification_objects)
    direct_link = get_direct_link(vehicle)

    if user_emails:
        email_type = '<b>ZEV model update</b>'
        send_email(list(user_emails), email_type, direct_link, test_info)


def send_model_year_report_emails(notifications, model_year_report):
    """
    Sends emails to subscribed users with model year report updates.

    :param notifications: Notification objects for the model year report event.
    :param request: The request object containing relevant data.
    """
    if settings.DEBUG:
        print('send_model_year_report_emails')
    
    request_type = 'model_year_report'
    user_emails = get_subscribed_user_emails(notifications, model_year_report, request_type)
    notification_objects = get_notification_objects(notifications)
    test_info = prepare_test_info(model_year_report, notification_objects)
    direct_link = get_direct_link(model_year_report)

    if user_emails:
        email_type = '<b>model year report update</b>'
        send_email(list(user_emails), email_type, direct_link, test_info)


def send_credit_agreement_emails(notifications, agreement):
    """
    Sends emails to subscribed users with credit agreement updates.

    :param notifications: Notification objects for the credit agreement event.
    :param agreement: The credit agreement object.
    """
    if settings.DEBUG:
        print('send_credit_agreement_emails')
    
    request_type = 'credit_agreement'
    user_emails = get_subscribed_user_emails(notifications, agreement, request_type)
    notification_objects = get_notification_objects(notifications)
    test_info = prepare_test_info(agreement, notification_objects)
    direct_link = get_direct_link(agreement)

    if user_emails:
        email_type = '<b>credit agreement update</b>'
        send_email(list(user_emails), email_type, direct_link, test_info)
